#pragma kernel CSMain

// take in voxel cases
// take in triangle table
// take in edge table
// take in vertices (output)
// take in triangles (output)

RWTexture2DArray<float> voxels;                 // voxel data computed by Evaluation.compute 
RWStructuredBuffer<int> triangleTable;          // triangle table lookup
RWStructuredBuffer<float3> edgeTable;           // edge table lookup
AppendStructuredBuffer<float3> vertexBuffer;    // vertices for mesh    (output)
AppendStructuredBuffer<int> triangleBuffer;     // triangles for mesh   (output)

// sample slope / density function here (maybe)

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int voxelCase = int(voxels[id.xyz] * 1000);

    // ignore cases with no geometry
    if (voxelCase != 0 && voxelCase != 255) {
        
        float3 coord = float3(id.x, id.y, id.z);

        // TODO:
        // create a Polygon struct so that we can append one polygon at a time instead of one vertex / one triangle.
        // create another compute shader designed to unpack those polygons into vertices and triangles arrays.

        // triangle table lookup and edge table lookup
        for (int i = 0; triangleTable[vertexCase * 16 + i] != -1; i++) {
            vertexBuffer.Append(Interpolate(triangleTable[vertexCase * 16 + i], coord));
            triangleBuffer.Append()
        }

        // just for reference, delete later.
        for (int i = 0; triangleTable[vertexCase][i] != -1; i += 3) {
                vertices[bufferIndex + 0] = Interpolate(triangleTable[vertexCase][i + 2], coord);
                vertices[bufferIndex + 1] = Interpolate(triangleTable[vertexCase][i + 1], coord);
                vertices[bufferIndex + 2] = Interpolate(triangleTable[vertexCase][i + 0], coord);

                triangles[bufferIndex + 0] = bufferIndex + 0;
                triangles[bufferIndex + 1] = bufferIndex + 1;
                triangles[bufferIndex + 2] = bufferIndex + 2;
                
                bufferIndex += 3;
            }

        // interpolation
        // set vertices and triangles

        Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);}
}
